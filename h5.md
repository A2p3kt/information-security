# h5 Uryyb, Greb!

## Reading Summaries

### Schneier 2015: Applied Cryptography: Chapter 1: Foundations

- Cryptography basics: transforms plaintext into unreadable ciphertext using algorithms and secret keys.
- Kerckhoffs’ Principle: system security must rely on secret keys, not on keeping algorithms secret.
- Symmetric cryptography: uses the same key for encryption and decryption; efficient but requires secure key exchange.
- Asymmetric cryptography: uses public/private key pairs; enables digital signatures and secure communication without prior key sharing.
- Cryptanalysis: study of breaking ciphers; modern ciphers are judged by their resistance to known attack types.
- Attack models: ciphertext-only, known-plaintext, chosen-plaintext, and chosen-ciphertext attacks.
- Confusion and diffusion: key design principles: obscure the link between key and ciphertext (confusion) and spread information widely (diffusion).
- Redundancy in language: natural patterns can help attackers; compression reduces redundancy before encryption.
- Steganography vs. cryptography: steganography hides the existence of a message, cryptography hides the content; best used together.
- Protocols and practicality: failures often arise from flawed cryptographic protocols or human errors, not from broken math; real security balances strength with usability.

Reading this chapter highlights that cryptography is not just about complex mathematics but also about principles and practical application. I found it especially interesting that the strength of a system should depend on the secrecy of the key, not the algorithm. I always assumed that the reverse was the case.

### Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg

- PGP basics – Encryption ensures confidentiality; signing ensures authenticity and integrity; both rely on public/private key pairs.
- GNU Privacy Guard (gpg) – open-source PGP implementation, widely used (e.g. Linux kernel development).
- Keypairs – Each user generates a keypair: public key (shared) and private key (kept secret).
- Export/import keys – Users share public keys via ASCII-armored files; importing makes them available for encryption/verification.
- Trust model – After importing, users must verify and sign each other’s keys (via fingerprint check) to establish trust.
- Alice & Tero simulation – Example walkthrough shows Alice generating keys, importing Tero’s key, and vice versa, in isolated directories.
- Encrypting a message – Alice encrypts using Tero’s public key so only Tero can decrypt it.
- Signing a message – Alice signs with her private key; Tero verifies the signature with Alice’s public key.
- Decryption and verification – Tero uses his private key to decrypt and confirms Alice’s identity through signature verification.
- Practical issues – Common errors (e.g., missing keys, confused gpg-agent) are solved with commands like killall gpg-agent and re-importing keys.

This article gave me a very practical, hands-on introduction to how PGP works in real life. I liked how it simulated Alice and Tero without needing separate systems, it made the process much clearer. What stood out was how public keys can be safely shared even over insecure networks, but trust still requires careful verification (like fingerprint checks). But one thing I am still finding it difficult to wrap my head around is the specifics of how the verification of the public keys work.

## OpenSSH Server

Getting started with SSH, I first ran the commands
```bash
sudo apt-get update
sudo apt-get install ssh
```

This installed SSH on my VM.

Now to connect to it, I ran
```bash
sudo systemctl start ssh
```
To start the server, then I ran `sudo systemctl status ssh` to confirm whether the server was active and this was the output I got, showing that the server is active

<img width="835" height="76" alt="image" src="https://github.com/user-attachments/assets/9725e40d-05db-4c20-b09f-72b99c1d10a5" />

With the server active, I ran the command `whoami` to get the name of my pc, the name, as of when I wrote this report, was "santa". Then I ran the command
```bash
ssh santa@localhost
```

As it was my first time connecting, it required confirmation and I had to input a password too, as shown below

<img width="1065" height="285" alt="image" src="https://github.com/user-attachments/assets/9726cdad-1ef7-4bbf-9060-682731b2bc3c" />

After all this, I ran `exit` to close the connection.

To be sure everything worked as expected, I ran the command `ssh santa@localhost` again, and this time, it didn't require any confirmation, it just asked for the password and once I typed it in, the connection was established.

### Automating SSH connections with public keys

With the SSH server still active, I ran the command `ssh-keygen`. I was asked for the path where I want the key to be saved, I didn't input anything, I went with the default. Also, I didn't input a passphrase, I left that blank too. It generated some randomart at the end.

<img width="811" height="397" alt="image" src="https://github.com/user-attachments/assets/ef257caa-c565-4745-a69b-b3509e0c3a3e" />

I then run `ssh-copy-id santa@localhost` to copy the public key to the server, I was then prompted for my password, and then the key was successfully add, as shown below

<img width="1297" height="186" alt="image" src="https://github.com/user-attachments/assets/dc740169-e966-4cc5-b2e5-09b9df17f117" />

Now, when I run `ssh santa@localhost` I am not prompted for a password meaning that I have successfully automated the process with the use of public and private keys.


## Cloudless Password Manager

For the password manager, I went on Reddit and searched for a secure password manager for Linux, and I decided to go with [KeePassXC](https://keepassxc.org/) because it was the most popular.

Installing it on my debian was very straightforward: `sudo apt-get install keepassxc`

After installing, I ran it from the application finder, by double clicking on it

<img width="587" height="453" alt="image" src="https://github.com/user-attachments/assets/794aa49a-adea-493c-bc85-9c549fec1bb4" />

Then I click on create new database 

<img width="815" height="639" alt="image" src="https://github.com/user-attachments/assets/63ce8980-3fdd-4dc5-b750-7826a54f14b2" />

Give the new database a name, I went with the default, "Passwords" and I left the description blank
<img width="815" height="639" alt="image" src="https://github.com/user-attachments/assets/06c20ca8-0b1c-4609-b6e1-3580a628345e" />

I am then asked to set the encryption settings, and because I am not to familiar with how it works, I just leave it on the default
<img width="615" height="557" alt="image" src="https://github.com/user-attachments/assets/942e1bbc-8612-45aa-bbec-9256c8e6c0d2" />

I am then prompted to set my database credentials
I use an automatically generated strong password
<img width="599" height="479" alt="image" src="https://github.com/user-attachments/assets/d48eda50-97c1-4e07-841e-c125316ca336" />

And then I choose where the database would be stored
<img width="1209" height="921" alt="image" src="https://github.com/user-attachments/assets/fba0b56e-01ee-40ef-9360-6ce231fce43c" />

Now to add the passwords, on the menu bar I click on entries and then new entry, I then fill in the necessary information like the username, password, url, and even the expiry date of the password if applicable and then save

<img width="789" height="419" alt="image" src="https://github.com/user-attachments/assets/2c84c1ce-530c-49ba-b50b-e658a70cd212" />

I could do this for as many credentials that I have, and the neat thing is that most browsers like firefox and chrome have extensions that can connect to this database and update the list of credentials automatically as I signup to new sites and also retrieve them when I need to sign in.

So if I need to retrieve any of my passwords, I just open the app, input my password, and get the password I need.

A password manager is very important because it generates strong passwords which are randomly generated and long. They are nearly impossible to guess making it hard for attackers to crack or bruteforce. Also password managers enforce uniqueness of passwords across multiple sites, so that if one site has a data breach, attackers can't use the same credentials to access your other accounts. Another thing that password managers do is that they simplify security. By having a central, secure location for all your passwords, it makes it easier to manage your digital life and update passwords regularly.


