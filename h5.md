# h5 Uryyb, Greb!

## Reading Summaries

### Schneier 2015: Applied Cryptography: Chapter 1: Foundations

- Cryptography basics: transforms plaintext into unreadable ciphertext using algorithms and secret keys.
- Kerckhoffs’ Principle: system security must rely on secret keys, not on keeping algorithms secret.
- Symmetric cryptography: uses the same key for encryption and decryption; efficient but requires secure key exchange.
- Asymmetric cryptography: uses public/private key pairs; enables digital signatures and secure communication without prior key sharing.
- Cryptanalysis: study of breaking ciphers; modern ciphers are judged by their resistance to known attack types.
- Attack models: ciphertext-only, known-plaintext, chosen-plaintext, and chosen-ciphertext attacks.
- Confusion and diffusion: key design principles: obscure the link between key and ciphertext (confusion) and spread information widely (diffusion).
- Redundancy in language: natural patterns can help attackers; compression reduces redundancy before encryption.
- Steganography vs. cryptography: steganography hides the existence of a message, cryptography hides the content; best used together.
- Protocols and practicality: failures often arise from flawed cryptographic protocols or human errors, not from broken math; real security balances strength with usability.

Reading this chapter highlights that cryptography is not just about complex mathematics but also about principles and practical application. I found it especially interesting that the strength of a system should depend on the secrecy of the key, not the algorithm. I always assumed that the reverse was the case.

### Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg

- PGP basics – Encryption ensures confidentiality; signing ensures authenticity and integrity; both rely on public/private key pairs.
- GNU Privacy Guard (gpg) – open-source PGP implementation, widely used (e.g. Linux kernel development).
- Keypairs – Each user generates a keypair: public key (shared) and private key (kept secret).
- Export/import keys – Users share public keys via ASCII-armored files; importing makes them available for encryption/verification.
- Trust model – After importing, users must verify and sign each other’s keys (via fingerprint check) to establish trust.
- Alice & Tero simulation – Example walkthrough shows Alice generating keys, importing Tero’s key, and vice versa, in isolated directories.
- Encrypting a message – Alice encrypts using Tero’s public key so only Tero can decrypt it.
- Signing a message – Alice signs with her private key; Tero verifies the signature with Alice’s public key.
- Decryption and verification – Tero uses his private key to decrypt and confirms Alice’s identity through signature verification.
- Practical issues – Common errors (e.g., missing keys, confused gpg-agent) are solved with commands like killall gpg-agent and re-importing keys.

This article gave me a very practical, hands-on introduction to how PGP works in real life. I liked how it simulated Alice and Tero without needing separate systems, it made the process much clearer. What stood out was how public keys can be safely shared even over insecure networks, but trust still requires careful verification (like fingerprint checks). But one thing I am still finding it difficult to wrap my head around is the specifics of how the verification of the public keys work.

## OpenSSH Server

Getting started with SSH, I first ran the commands
```bash
sudo apt-get update
sudo apt-get install ssh
```

This installed SSH on my VM.

Now to connect to it, I ran
```bash
sudo systemctl start ssh
```
To start the server, then I ran `sudo systemctl status ssh` to confirm whether the server was active and this was the output I got, showing that the server is active

<img width="835" height="76" alt="image" src="https://github.com/user-attachments/assets/9725e40d-05db-4c20-b09f-72b99c1d10a5" />

