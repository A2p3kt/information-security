# h7: February2025!

## Reading Summaries

### Schneier 2015: Applied Cryptography

#### Chapter 2.3: One-Way Functions

- One-way functions are easy to compute but extremely difficult to reverse.
- Their difficulty lies in the fact that reversing them would take an impractical amount of time.
- The smashed plate analogy shows how easy it is to go one way, but not the other.
- There’s no mathematical proof that true one-way functions exist, only strong candidates.
- They seem one-way because no efficient method for reversing them is currently known.
- They can’t be used for direct encryption since the original message can’t be recovered.
- Trapdoor one-way functions include secret information that makes reversing possible, forming the basis for public-key cryptography.

#### Chapter 2.4: One-Way Hash Functions

- One-way hash functions, also called message digests or fingerprints, are key tools in modern cryptography.
- They convert variable-length input data into a fixed-length output called a hash value.
- The goal is to create a unique fingerprint that can verify data integrity without revealing the original input.
- A good one-way hash function is easy to compute but hard to reverse or find collisions for.
- Even a tiny change in the input drastically changes the output, making patterns impossible to spot.
- They’re often used to confirm data authenticity, like verifying files or preventing tampering in transactions.
- A Message Authentication Code (MAC) adds a secret key, allowing only authorized users to verify the hash.

## Getting Started with Hashcat

### Installation & Setup

Installing hashcat was straightforward. I ran the commands below:
```bash
sudo apt-get update
sudo apt-get -y install hashid hashcat wget
```

In addition to installing hashcat, I installed two other tools `hashid`, for identifying password hashes, and `wget`, a command-line utility for downloading from the web.

Then I created a directory for my work
```bash
mkdir hash_practice
cd hash_practice
```

Next I get a big dictionary of passwords called `rockyou`:
```bash
wget https://github.com/danielmiessler/SecLists/raw/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz
```
This command downloads the compressed file `rockyou.txt.tar.gz`

To unpack it I run:
```bash
tar xf rockyou.txt.tar.gz
```
`tar` is used to unpack archive files, and `x` means extract and `f` tells the file to use the following file, `rockyou.txt.tar.gz`.

Now I have `rockyou.txt` ready to be used and I can now delete the archive file, and I do that by running
```bash
rm rockyou.txt.tar.gz
```

### Testing a Simple Hash

I tested the functionality of hashcat by trying the example in the course material.
The hash to be solved is `6b1628b016dff46e6fa35684be6acc96`

Now before I can try to solve the hash, I should know the type of hash, and this is where `hashid` comes handy, so I run:

```bash
hashid -m 6b1628b016dff46e6fa35684be6acc96
```
`-m` tells hashid to show the Hashcat mode numbers along with the algorithm name

So it yields this:

<img width="855" height="378" alt="image" src="https://github.com/user-attachments/assets/772ecb39-6f1a-416e-967e-af897daf8151" />

Following the example I try `MD5` as it is more common

so I run the command:

```bash
hashcat -m 0 '6b1628b016dff46e6fa35684be6acc96' rockyou.txt -o solved
```

And what this command does is:
<img width="1560" height="442" alt="{9303DBB4-1016-412C-8277-CBD5442A289B}" src="https://github.com/user-attachments/assets/24199833-5e41-4611-93ba-28b5fc8318d1" />

It takes a bit of time to finish, but when it is done, I run `ls` and I see the solved file, and I run `cat solved` to see the content of the file, and this was the result
<img width="466" height="100" alt="image" src="https://github.com/user-attachments/assets/6f2129e3-4a27-461a-871a-c9fc6dc02003" />

This means the password was `summer`. Really thrilling to see how it works.

## Cracking a Hash

The hash to be cracked is `d595b2086532422bbe654bc07ea030df`

So to begin, I use hashid to try and guess the hashing algorithm used:

```bash
hashid -m d595b2086532422bbe654bc07ea030df
```
<img width="867" height="378" alt="image" src="https://github.com/user-attachments/assets/0ca842b3-d7f8-4c3d-8266-9c8a139b61a2" />

Now again there are a few options, and I will try `MD5` once more and see what it will yield. So I run:
```bash
hashcat -m 0 'd595b2086532422bbe654bc07ea030df' rockyou.txt -o solved
```

And after it finishes running, I run `cat solved` to see the result and this was the result:

<img width="543" height="95" alt="image" src="https://github.com/user-attachments/assets/747ac6e5-d5c8-4503-9e1f-14a3f6318152" />

this shows that the password was `disobey`.

To be sure that this is the correct solution, out of curiosity I decided to try whether the other hashing algorithms would yield a different password, so I ran the command
```bash
hashcat -m 900 'd595b2086532422bbe654bc07ea030df' rockyou.txt -o solved
```
To try with the MD4 algorithm too, but I ran into an issue

<img width="1572" height="210" alt="image" src="https://github.com/user-attachments/assets/982c9c1d-c10f-4a22-885a-6219334ed3d7" />

From the screenshot, it can be seen that Hashcat did not attempt to crack the hash again. Instead, it displayed a message stating that the hash was found in the potfile, which is a file that stores all previously cracked hashes. The tool then advised using the `--show` option to view the stored result.

Now after some searching online, and some conversations with some AI models, Gemini 2.5 specifically, I was able to find a way around it

<img width="1418" height="275" alt="image" src="https://github.com/user-attachments/assets/fc17b229-b727-4c3c-99f2-4fa43d5720af" />
```bash
hashcat -m 900 -a 0 d595b2086532422bbe654bc07ea030df wordlist.txt --session new_run --potfile-disable -o cracked.txt
```
This was the response of the model, with the suggested command, so I tweaked it a bit to match my exact situation and the final command I ran was
```bash
hashcat -m 900 d595b2086532422bbe654bc07ea030df rockyou.txt --session new_run --potfile-disable -o solved
```

And it worked
<img width="1021" height="351" alt="image" src="https://github.com/user-attachments/assets/11410a8f-8dff-48a2-b770-e86b1fab7a23" />

As shown in the screenshot, the hash was not successfully cracked but instead marked as *exhausted*. I repeated the process two more times using other algorithms suggested by `hashid`, but each attempt produced the same outcome. These consistent results strengthened my confidence that the actual password was indeed "disobey".


